(load "putget.scm")
(load "complex-package.scm")
(load "arithmetic.scm")
(define (apply-generic op . args)
;  (newline)
;  (display "apply-generic")
;  (display op)
;  (display "->")
;  (display args)
  (let ((type-tags (map type-tag args)))
    (let ((proc (get op type-tags)))
      (if proc
	(if (or (eq? op 'sub) (eq? op 'div) (eq? op 'add) (eq? op 'mul) 
		(eq? op 'make-rational) 
		(eq? op 'make-complex-from-real-imag)
		(eq? op 'make-complex-from-mag-ang))
	(drop (apply proc (map contents args))) 
	 (apply proc (map contents args)))
	(if (= (length args) 2)
	    (let ((level1 (level (car args)))
		  (level2 (level (cadr args))))
	      (cond ((= level1 level2)
		     (error "No method for types" (list op type-tags)))
		    ((< level1 level2) 
		     (apply-generic op (car args) (raise (cadr args))))
		    (else 
		      (apply-generic op (raise (car args)) (cadr args))))) 
	    (error "No method for these types" (list op type-tags)))))))  
(define (install-raise-package)
  (put 'raise '(integer) 
		(lambda (n)  ((get 'make 'rational) n 1)))
  (put 'raise '(rational) 
		(lambda (r)
		  (make-real (/ (+ 0.0 ((get 'numer '(rational)) r))
			       (+ 0.0 ((get 'denom '(rational)) r))))))
  (put 'raise '(real) 
		(lambda (x)  (make-complex-from-real-imag x 0)))
  'done)
(install-raise-package)
(define (install-projection)
  (define (project-complex z)
 	(make-real (real-part z)))
  (define (project-real x)
        (make-integer (inexact->exact (round x))))
  (define (project-rational r)
    (let ((projection ((get 'numer '(rational)) r)))
      (if (and (pair? projection) (eq? (car projection) 'polynomial))
	 projection 
	(make-integer projection))))
  (put 'project '(complex) project-complex)
  (put 'project '(real) project-real)
  (put 'project '(rational) project-rational)
  'done
 )
(install-projection)
(define (project x) 
  (apply-generic 'project x))
(define (drop x)
  (newline)
  (display "dropping:")
  (display x)
  (if (get 'project (list (type-tag x)))
    (if (equ? x (project x))
      (drop (project x))
      x)
    x))
(define (raise x) 
  ;(newline)
  ;(display "raise")
  ;(display x)
  (apply-generic 'raise x))
(define (level x)
  (if (get 'raise (list (type-tag x)))
    (+ 1 (level (raise x)))
    0))
;(define z1 (make-complex-from-real-imag 2 0))
;(drop z1)
;(drop (div (make-integer 2) (make-integer 1)))
