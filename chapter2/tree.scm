(define (entry tree) (car tree))
(define (left-branch tree) (cadr tree))
(define (right-branch tree) (caddr tree))
(define (make-tree entry left right)
  (list entry left right))
(define (element-of-set? x set)
  (cond ((null? set) #f)
        ((= x (entry set)) #t)
        ((> x (entry set)) (element-of-set? x (right-branch set)))
        ((< x (entry set)) (element-of-set? x (left-branch)))))
(define (adjoin-set x set)
  (cond ((null? set) (make-tree x '() '()))
        ((= x (entry set) set))
        ((> x (entry set)
            (make-tree (entry set)
                       (left-brach set)
                       (adjoin-set x (right-branch set)))))
        ((< x (entry set)
            (make-tree (entry set)
                       (adjoin-set x (left-branch set))
                       (right-branch set))))))
(define (list->tree elements)
  (define (partial-tree elts n)
    (if (= n 0)
      (cons '() elts)
      (let ((left-size (quotient (- n 1) 2)))
        (let ((left-result
                (partial-tree elts left-size)))
          (let ((left-tree (car left-result))
                 (non-left-elts (cdr left-result))
                 (right-size (- n (+ left-size 1))))
            (let ((this-entry (car non-left-elts))
                  (right-result (partial-tree
                                  (cdr non-left-elts)
                                  right-size)))
              (let ((right-tree (car right-result))
                    (remaining-elts
                      (cdr right-result)))
                (cons (make-tree this-entry
                                 left-tree
                                 right-tree)
                      remaining-elts))))))))
  (car (partial-tree elements (length elements))))
(define (tree->list tree)
  (define (copy-to-list tree result-list)
    (if (null? tree)
      result-list
      (copy-to-list (left-branch tree)
		    (cons (entry tree)
			  (copy-to-list
			    (right-branch tree)
			    result-list)
			  ))))
  (copy-to-list tree '()))
;2.65 (define (union-tree tree1 tree2)
;(list->tree (union-set (tree->list tree1) (tree->list tree2))))
(define (lookup-tree given-key tree-of-records)
  (if (null? tree-of-records) #f
    (let ((entry-key (key (car tree-of-records))))
      (cond ((= given-key entry-key) (car tree-of-records))
	    ((< given-key entry-key) 
	     (lookup-tree given-key (left-branch tree-of-records)))
	    (else  (lookup-tree given-key right-branch tree-of-records))))))
(define (make-leaf symbol weight)
  (list 'leaf symbol weight))
(define (leaf? object)
  (eq? (car object) 'leaf))
(define (symbol-leaf x) (cadr x))
(define (weight-leaf x) (caddr x))
(define (make-code-tree left right)
  (list left
	right
	(append (symbols left)
		(symbols right))
	(+ (weight left)
	   (weight right))))
(define (left-branch tree) (car tree))
(define (right-branch tree) (cadr tree))
(define (symbols tree)
  (if (leaf? tree)
    (list (symbol-leaf tree))
    (caddr tree)))
(define (weight tree)
  (if (leaf? tree)
    (weight-leaf tree)
    (cadddr tree)))
(define (decode bits tree)
  (define (decode-1 bits current-branch)
    (if (null? bits) '()
      (let ((next-branch (choose-branch (car bits) current-branch)))
	(if (leaf? next-branch)
	  (cons (symbol-leaf next-branch)
		(decode-1 (cdr bits) tree))
	  (decode-1 (cdr bits) next-branch)))))
  (decode-1 bits tree))
(define (choose-branch bit tree)
  (cond ((= bit 0) (left-branch tree))
	((= bit 1) (right-branch tree))
	(else (error "bad bit: CHOOSE-BRANCH" bit))))
(define (adjoin-set x set)
  (cond ((null? set) (list x))
	((< (weight x) (weight (car set)))
	 (cons x set))
	(else
	  (cons (car set) (adjoin-set x (cdr set))))))
(define (make-leaf-set pairs)
  (if (null? pairs)
    '()
    (let ((pair (car pairs)))
      (adjoin-set (make-leaf
		    (car pair)     ;symbol
		    (cadr pair))   ;frequency
		  (make-leaf-set (cdr pairs))))))
(define sample-tree
  (make-code-tree (make-leaf 'A 4)
		  (make-code-tree
		    (make-leaf 'B 2)
		    (make-code-tree (make-leaf 'D 1)
				    (make-leaf 'C 1)))))
(define sample-message '(0 1 1 0 0 1 0 1 0 1 1 1 0))
(decode sample-message sample-tree)
(define (encode message tree)
  (if (null? message)
    '()
    (append (encode-symbol (car message) tree)
	    (encode (cdr message) tree))))
(define (encode-symbol word tree)
  (define (iter word current-tree bits)
    (if (leaf? current-tree)
      (if (eq? word (symbol-leaf current-tree))
	       bits
	       '())
      (append (iter word (left-branch current-tree) (append bits (list 0)))
	      (iter word (right-branch current-tree) (append bits (list 1))))))
  (let ((bits (iter word tree '())))
    (if (null? bits)
      (error "word not in tree" word)
      bits)))
(define (encode-symbol word tree)
  (define (word-in-list? word list)
    (cond ((null? list) #f)
	  ((eq? word (car list)) #t)
	  (else (word-in-list? word (cdr list))))) 
  (if (leaf? tree) '()
    (cond ((word-in-list? word (symbols (left-branch tree)))
	   (cons 0 (encode-symbol word (left-branch tree))))
	  ((word-in-list? word (symbols (right-branch tree)))
	   (cons 1 (encode-symbol word (right-branch tree))))
	  (else (error "word not in tree" word)))))
(define pairs (list (list 'A 4) (list 'B 2) (list 'C 1) (list 'D 1)))
(define (generate-huffman-tree pairs)
  (successive-merge (make-leaf-set pairs)))
(define (successive-merge code-list)
  (define (adjoin obj rest)
    (cond ((null? rest) (list obj))
	  ((< (weight obj) (weight (car rest)))
	   (cons obj rest))
	  (else (cons (car rest) (adjoin obj (cdr rest))))))
  (if (null? (cdr code-list))
    (car code-list)
    (let ((left (car code-list))
	  (right (cadr code-list))
	  (rest (cddr code-list)))
      (successive-merge (adjoin (make-code-tree left right)
	      rest)))))
(generate-huffman-tree pairs)
