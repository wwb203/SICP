(load "coercion.scm")
(load "seq.scm")
(define (install-polynomial-package) 
;;internal procedures
;;representation of poly
(define (make-poly variable term-list)
  (cons variable term-list))
(define (variable p)
  (car p))
(define (term-list p) (cdr p))
(define (variable? x) (symbol? x))
(define (same-variable? v1 v2)
  (and (variable? v1) (variable? v2) 
       (or (eq? v1 'any) 
	   (eq? v2 'any)
	   (eq? v1 v2))))
(define (non-num-var v1 v2)
  (if (eq? v1 'any)
    v2
    v1))
(define (negative-poly p)
  (make-poly (variable p) 
	     (negative (term-list p))))
(define (add-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
    (make-poly (non-num-var (variable p1) (variable p2))
	       (add (term-list p1) (term-list p2)))
    (cdr (add (canonical-poly (cons 'polynomial  p1)) 
	 (canonical-poly (cons 'polynomial  p2))))))
(define (equ?-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
    (equ? (term-list p1) (term-list p2))
    false))

(define (mul-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
    (make-poly (non-num-var (variable p1) (variable p2))
	       (mul (term-list p1) (term-list p2)))
    (cdr (mul (canonical-poly (cons 'polynomial  p1)) 
	 (canonical-poly (cons 'polynomial  p2))))))
(define (div-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
   (map (lambda (L)
	  (make-poly (non-num-var (variable p1)
				  (variable p2))
		     L)) (div (term-list p1) (term-list p2))) 
    (error "DIV different variable:" (list p1 p2))))
(define (sub-poly p1 p2)
  (add-poly p1 (negative-poly p2)))
(define (gcd-poly p1 p2)
  (if (same-variable? (variable p1) (variable p2))
	(make-poly (non-num-var (variable p1)
				  (variable p2))
		   (greatest-common-divisor
			   (term-list p1) (term-list p2))) 
    (error "DIV different variable:" (list p1 p2))))
(define (reduce-poly p1 p2)
   (if (same-variable? (variable p1) (variable p2))
	(map (lambda (L) 
	       (make-poly (non-num-var (variable p1)
				  (variable p2)) L))
	     (reduce (term-list p1) (term-list p2)))
   (error "reduce-poly different variable:" (list p1 p2))))  
;;interface to rest of the system
(define (tag p) (attach-tag 'polynomial p))
(put 'add '(polynomial polynomial)
     (lambda (p1 p2) (tag (add-poly p1 p2))))
(put 'mul '(polynomial polynomial)
     (lambda (p1 p2) (tag (mul-poly p1 p2))))
(put 'sub '(polynomial polynomial)
     (lambda (p1 p2) (tag (sub-poly p1 p2))))
(put 'div '(polynomial polynomial)
     (lambda (p1 p2) (map tag (div-poly p1 p2))))
(put 'greatest-common-divisor '(polynomial polynomial)
     (lambda (p1 p2) (tag (gcd-poly p1 p2))))
(put 'make 'polynomial
     (lambda (var terms) (tag (make-poly var terms))))
(put 'negative '(polynomial) 
     (lambda (p) (tag (negative-poly p))))
(put '=zero? '(polynomial)
     (lambda (p) (=zero? (term-list p))))
(put 'equ? '(polynomial polynomial)
     (lambda (p1 p2) (equ?-poly p1 p2)))
(put 'raise '(sparse)
     (lambda (L) 
       (tag (make-poly 'any  
		       (cons 'sparse 
			     L)))))
(put 'raisetag 'sparse 
     (lambda () 'polynomial))
(put 'reduce '(polynomial polynomial)
     (lambda (p1 p2)
       (map tag (reduce-poly p1 p2))))
(put 'project '(polynomial)
     (lambda (p)  
       ((get 'project 'sparse) (cdr (term-list p)))))
'done
)
(install-polynomial-package) 
(define (reduce L1 L2)
  (apply-generic 'reduce L1 L2))
(define (install-rat-poly-package)
  ;;internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
    (let ((g (greatest-common-divisor n  d )))
      (cons (car (div n g)) (car (div d g)))
     )
    )
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y))
		 (mul (numer y) (denom x)))
	      (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (negative (mul (numer x) (denom y))
		 (mul (numer y) (denom x)))
	      (mul (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (mul (numer x) (numer y))
	      (mul (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (mul (numer x) (denom y))
	      (mul (denom x) (numer y))))
  ;;interface to rest of the system
  (define (tag x) (attach-tag 'rat-poly x))
  (put 'add '(rat-poly rat-poly)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rat-poly rat-poly)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rat-poly rat-poly)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rat-poly rat-poly)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'make 'rat-poly
       (lambda (n d) (tag (make-rat n d))))
  (put 'numer '(rat-poly) numer)
  (put 'denom '(rat-poly) denom)
  (put 'negative '(rat-poly)
       (lambda (x) (tag (make-rat (negative (numer x)) (denom x)))))
  (put 'raise '(polynomial)
       (lambda (p) (tag (make-rat (cons 'polynomial p) 
				 (make-polynomial 'any
				  (cons 'sparse 
					(list (list 0 1))))))))
  (put 'equ? '(rat-poly rat-poly)
       (lambda (rf1 rf2)
	 (and (equ? (numer rf1) (numer rf2))
	      (equ? (denom rf1) (denom rf2)))))
  (put 'project '(rat-poly)
       (lambda (rat) (numer rat)))
  (put 'raisetag 'polynomial
       (lambda () 'rat-poly))
  'done
)
(install-rat-poly-package)
(define (make-rat-poly p1 p2) ((get 'make 'rat-poly) p1 p2))

(define (greatest-common-divisor x y) 
  (apply-generic 'greatest-common-divisor x y))
(define (install-sparse-term-list-package) 

 (define (tag x) (cons 'sparse x))
 (define (the-empty-termlist) '())
 (define (first-term term-list) (car term-list))
 (define (rest-terms term-list) (cdr term-list))
 (define (empty-termlist? term-list) (null? term-list))
 (define (make-term order coeff) (list order coeff))
 (define (order term) (car term))
 (define (coeff term) (cadr term)) 
 (define (=zero-termlist? termlist)
   (or (empty-termlist? termlist)
       (=zero? (coeff (first-term termlist)))))
 (define (adjoin-term term term-list)
  (if (=zero? (coeff term))
    term-list
    (cons term term-list))) 
 (define (equ?-terms L1 L2)
   (cond ((empty-termlist? L1) (empty-termlist? L2))
	 ((empty-termlist? L2) (empty-termlist? L1))
	 (else (let ((t1 (first-term L1))
		     (t2 (first-term L2)))
		 (and (equ? (order t1) (order t2))
		      (equ? (coeff t1) (coeff t2))
		      (equ?-terms (rest-terms L1)
				  (rest-terms L2)))))))
(define (add-terms L1 L2)
  (cond ((empty-termlist? L1) L2)
	((empty-termlist? L2) L1)
	(else
	  (let ((t1 (first-term L1))
		(t2 (first-term L2)))
	    (cond ((> (order t1) (order t2))
		   (adjoin-term
		     t1 (add-terms (rest-terms L1) L2)))
		  ((< (order t1) (order t2))
		   (adjoin-term
		     t2 (add-terms L1 (rest-terms L2))))
		  (else
		    (adjoin-term
		      (make-term (order t1)
				 (add (coeff t1) (coeff t2)))
		      (add-terms (rest-terms L1)
				 (rest-terms L2)))))))))
(define (negative-term-list L)
  (if (empty-termlist? L)
    (the-empty-termlist)
    (let ((t (first-term L)))
      (adjoin-term
	(make-term (order t) (negative (coeff t)))
	(negative-term-list (rest-terms L))))))
(define (mul-terms L1 L2)
  (if (empty-termlist? L1)
    (the-empty-termlist)
    (add-terms (mul-term-by-all-terms (first-term L1) L2)
	       (mul-terms (rest-terms L1) L2))))
(define (sub-terms L1 L2)
  (add-terms L1 (negative-term-list L2)))
(define (mul-term-by-all-terms t1 L)
  (if (empty-termlist? L)
    (the-empty-termlist)
    (let ((t2 (first-term L)))
      (adjoin-term 
      (make-term (+ (order t1) (order t2))
		 (mul (coeff t1) (coeff t2)))
      (mul-term-by-all-terms t1 (rest-terms L))))))
(define (div-terms L1 L2)
  (define (adjoin item seq)
    (if (null? seq)
      item
      (cons item seq)))
  (if (empty-termlist? L1)
    (list (the-empty-termlist) (the-empty-termlist))
    (let ((t1 (first-term L1))
	  (t2 (first-term L2)))
      (if (> (order t2) (order t1))
	     (list (the-empty-termlist) L1)
	     (let ((new-c (div (coeff t1) (coeff t2)))
		   (new-o (- (order t1) (order t2))))
	       (let ((rest-of-result
		       (div-terms (sub-terms L1 (mul-terms   
					  (list (list new-o new-c))
					  L2)) L2)))
		(list (cons (list new-o new-c) (car rest-of-result))
		      (cadr rest-of-result))))))))
(define (div-terms-factor L factor)
  (if (empty-termlist? L)
    (the-empty-termlist)
    (let ((t1 (first-term L)))
      (cons (make-term (order t1) (/ (coeff t1) factor))
	    (div-terms-factor (cdr L) factor)
	    )
      )))
(define (remainder-terms L1 L2)
  (cadr (div-terms L1 L2))
  )
(define (pseudoremainder-terms L1 L2)
  (let ((factor (expt (coeff (first-term L2))
		      (+ 1 (- (order (first-term L1))
			      (order (first-term L2)))))))
    (cadr (div-terms (mul-terms (list (list 0 factor)) L1) L2))))
(define (gcd-terms a b)
  (if (empty-termlist? b)
  (div-terms-factor a (gcd-list (map abs (map coeff a))))
   (gcd-terms b (pseudoremainder-terms a b))))
(define (gcd-list L)
  (cond ((= (length L) 1) (car L))
	((= (length L) 2) (gcd (car L) (cadr L)))
	(else
	(gcd-list (cons (gcd (car L) (cadr L))  (cddr L))))))
(define (reduce-terms L1 L2)
  (let ((gc (gcd-terms L1 L2)))
    (list (car (div-terms L1 gc)) (car (div-terms L2 gc)))))
;;interface
(put '=zero? '(sparse) =zero-termlist?)
(put 'add '(sparse sparse) (lambda (L1 L2)
			     (tag  (add-terms L1 L2))))
(put 'sub '(sparse sparse) (lambda (L1 L2)
			     (tag  (sub-terms L1 L2))))
(put 'mul '(sparse sparse) (lambda (L1 L2)
			     (tag  (mul-terms L1 L2))))
(put 'div '(sparse sparse) (lambda (L1 L2)
			     (map tag (div-terms L1 L2))))
(put 'reduce '(sparse sparse) (lambda (L1 L2)
				(map tag (reduce-terms L1 L2))))
(put 'negative '(sparse) (lambda (L)
			     (tag  (negative-term-list L))))
(put 'make-termlist 'sparse (lambda (L) (tag L)))
(put 'equ? '(sparse sparse) (lambda (L1 L2)
			      (equ?-terms L1 L2)))
(put 'first-term '(sparse) first-term)
(put 'empty-termlist? '(sparse) empty-termlist?)
(put 'greatest-common-divisor '(sparse sparse) (lambda (L1 L2)
			     (tag  (gcd-terms L1 L2))))
(put 'project 'sparse (lambda (L)
			  (coeff (first-term L))))
(put 'raise '(complex)
     (lambda (z) (cons 'sparse (list (list 0 (cons 'complex z))))))
(put 'raisetag 'complex (lambda () 'sparse))
'done
)
(install-sparse-term-list-package) 

(define (make-polynomial var terms)
  ((get 'make 'polynomial) var terms))
(define z1 (make-complex-from-real-imag 1 2))
(define (expand-poly p)
  (define (termlist L)
    (if (eq? (car L) 'sparse) (cdr L) 
      (cdr (raise L))))
  (cond ((null? p) '())
	((num? p) (list (list 'any p)))
	((eq? (type-tag p) 'polynomial)
	 (let ((var (cadr p))
	       (L (termlist (cddr p))))
	  (flatmap (lambda (term)
		(map (lambda (Le) (append (list var (car term)) Le)) 
			(expand-poly (cadr term)))) L))) 
	(else "unkown type EXPAND-POLY" p))) 
(define var-order (list 'x 'y))
(define (fold-term L)
  (define (collect-order var L)
    (if (null? L) 0
      (let ((Lvar (car L))
	    (Lorder (cadr L)))
	(if (eq? Lvar var)
	  (+ Lorder (collect-order var (cddr L)))
	  (collect-order var (cddr L))))))
  (define (collect-num L)
    (if (null? L) 1
      (let ((Lvar (car L))
	    (Lcoeff (cadr L)))
	(if (eq? Lvar 'any)
	  (mul Lcoeff (collect-num (cddr L)))
	  (collect-num (cddr L))))))
  (append  
  (map (lambda (var)  (collect-order var L)) var-order)
  (list (collect-num L)))) 
(define (fold-termlist L)
  (map fold-term L))
(define (adjoin-by-first-order item item-seq)
  (if (null? item-seq)
    (list item)
    (if (> (car item) (car (car item-seq)))
      (cons item item-seq)
      (cons (car item-seq) 
	    (adjoin-by-first-order item (cdr item-seq))))))
(define (sort-termlist termlist)
  (if (null? termlist)
    '()
    (adjoin-by-first-order (car termlist)
			   (sort-termlist (cdr termlist))
			   )))
(define (make-polynomial-from-termlist termlist var-list)
  (if (null? var-list)
   (car termlist) 
	(make-polynomial (car var-list)
			 (cons 'sparse
			      (list  (list (car termlist)
				     (make-polynomial-from-termlist
				       (cdr termlist)
				       (cdr var-list))))))))
(define (poly-sum-termlist termlist)
  (cond ((null? termlist) '())
	((= (length termlist) 1) 
	 (make-polynomial-from-termlist (car termlist) var-order))
	(else
	  (add  
	   (make-polynomial-from-termlist (car termlist) var-order) 
	   (poly-sum-termlist (cdr termlist))))))
(define (canonical-poly poly)
  (poly-sum-termlist (fold-termlist (expand-poly poly))))

(define p1 (make-polynomial 'x (cons 'sparse
				     (list (list 1 1)
					   (list 0 1)))))
(define p2 (make-polynomial 'x (cons 'sparse
				     (list (list 3 1) 
					   (list 0 -1)))))
(define p3 (make-polynomial 'x (cons 'sparse
				     (list (list 1 1)))))
(define p4 (make-polynomial 'x (cons 'sparse 
				     (list (list 2 1) 
				           (list 0 -1)))))
(define rf1 (make-rat-poly p1 p2))
(define rf2 (make-rat-poly p3 p4))
(add rf1 rf2)

