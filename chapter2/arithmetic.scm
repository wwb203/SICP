(install-rectangular-package)
(install-polar-package)
(define (num? num)
  (let ((type (type-tag num)))
    (or (eq? type 'integer)
	(eq? type 'real)
	(eq? type 'rational)
	(eq? type 'complex))))
(define (type-tag datum)
  (cond ((integer?? datum) 'integer)
	((real?? datum) 'real)
    	((pair? datum) (car datum))
	(else (error " Bad tagged datum: TYPE-TAG" datum))))
(define (integer?? x)
  (if (number? x)
    (eq? (- x (round x)) 0)
    false))
(define (real?? x)
  (and (number? x) (not (integer?? x))))
(define (attach-tag type-tag datum)
  (cond ((integer?? datum) datum)
	((real?? datum) datum)
	(else (cons type-tag datum))))
(define (contents datum)
  (cond ((number? datum) datum)
	((pair? datum) (cdr datum))
	(else "Bad tagged datum:CONTENTS" datum)))
(define (add x y)
  (apply-generic 'add x y))
(define (sub x y) (apply-generic 'sub x y))
(define (mul x y) (apply-generic 'mul x y))
(define (div x y) (apply-generic 'div x y))
(define (reduce-integers n d)
  (let ((g (gcd (abs n) (abs d))))
	(list (/ n g) (/ d g)))) 
(define (install-integer-package)
  (define (tag x) (attach-tag 'integer x))
  (define (gcd-integer a b)
    (if (= b 0)
      a
      (gcd-integer b (remainder a b))))
  (put 'gcd '(integer integer) (lambda (x y)
				 (tag (gcd-integer x y))
				 ))
  (put 'reduce '(integer integer)
       (lambda (x y)
	 (map tag (reduce-integers x y))))
  (put 'add '(integer integer)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(integer integer)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(integer integer)
       (lambda (x y) (tag (* x y))))
  (put 'div '(integer integer)
       (lambda (x y) ((get 'make 'rational) x y)))
  (put 'make 'integer (lambda (x) (tag x)))
  (put 'negative '(integer) (lambda (x) (tag (- x))))
  (put 'greatest-common-divisor '(integer integer)
       (lambda (x y) (tag (gcd-integer x y)))
       )
  'done
)
(install-integer-package)

(define (make-integer n)
  ((get 'make 'integer) n))
(define (install-real-package)
  (define (tag x) (attach-tag 'real x))

  (put 'add '(real real)
       (lambda (x y) (tag (+ x y))))
  (put 'sub '(real real)
       (lambda (x y) (tag (- x y))))
  (put 'mul '(real real)
       (lambda (x y) (tag (* x y))))
  (put 'div '(real real)
       (lambda (x y) (tag (/ x y))))

  (put 'make 'real (lambda (x) (tag x)))
  (put 'negative '(real)  (lambda (x) (tag (- x))))
  'done
)
(install-real-package)
(define (make-real x)
  ((get 'make 'real) x))
(define (install-rational-package)
  ;;internal procedures
  (define (numer x) (car x))
  (define (denom x) (cdr x))
  (define (make-rat n d)
  (let ((nndd (reduce n d)))
    (if (< (* n d) 0)
      (cons (negative (abs (car nndd)))
	    (abs (cadr nndd))) 
    (cons (abs (car nndd)) (abs (cadr nndd))))))
  (define (add-rat x y)
    (make-rat (add (mul (numer x) (denom y))
		 (mul (numer y) (denom x)))
	      (mul (denom x) (denom y))))
  (define (sub-rat x y)
    (make-rat (negative (mul (numer x) (denom y))
		 (mul (numer y) (denom x)))
	      (mul (denom x) (denom y))))
  (define (mul-rat x y)
    (make-rat (mul (numer x) (numer y))
	      (mul (denom x) (denom y))))
  (define (div-rat x y)
    (make-rat (mul (numer x) (denom y))
	      (mul (denom x) (numer y))))
  ;;interface to rest of the system
  (define (tag x) (attach-tag 'rational x))
  (put 'add '(rational rational)
       (lambda (x y) (tag (add-rat x y))))
  (put 'sub '(rational rational)
       (lambda (x y) (tag (sub-rat x y))))
  (put 'mul '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'div '(rational rational)
       (lambda (x y) (tag (mul-rat x y))))
  (put 'make 'rational
       (lambda (n d) (tag (make-rat n d))))
  (put 'numer '(rational) numer)
  (put 'denom '(rational) denom)
  (put 'negative '(rational)
       (lambda (x) (tag (make-rat (- (numer x)) (denom x)))))
  'done
  )
(install-rational-package)
(define (make-rational n d)
  ((get 'make 'rational) n d))
(install-rectangular-package)
(install-polar-package)
(define (install-complex-package)
  ;;imported procedures from rectangular and polar packages
  (define (make-from-real-imag x y)
    ((get 'make-from-real-imag 'rectangular) x y))
  (define (make-from-mag-ang r a)
    ((get 'make-from-mag-ang 'polar) r a))
  ;;internal procedures
  (define (add-complex z1 z2)
    (make-from-real-imag (add (real-part z1) (real-part z2))
			 (add (imag-part z1) (imag-part z2))))
  (define (sub-complex z1 z2)
    (make-from-real-imag (sub (real-part z1) (real-part z2))
			 (sub (imag-part z1) (imag-part z2))))
  (define (mul-complex z1 z2)
    (make-from-mag-ang (mul (magnitude z1) (magnitude z2))
		       (add (angle z1) (angle z2))))
  (define (div-complex z1 z2)
    (make-from-mag-ang (div (magnitude z1) (magnitude z2))
		       (sub (angle z1) (angle z2))))
  ;;interface to the rest of the system
  (define (tag z) (attach-tag 'complex z))
  (put 'add '(complex complex)
       (lambda (z1 z2) (tag (add-complex z1 z2)))) 
  (put 'sub '(complex complex)
       (lambda (z1 z2) (tag (sub-complex z1 z2))))
  (put 'mul '(complex complex)
       (lambda (z1 z2) (tag (mul-complex z1 z2))))
  (put 'div '(complex complex)
       (lambda (z1 z2) (tag (div-complex z1 z2))))
  (put 'make-from-real-imag 'complex 
       (lambda (x y) (tag (make-from-real-imag x y)))) 
  (put 'make-from-mag-ang 'complex
       (lambda (r a) (tag (make-from-mag-ang r a))))
  'done)
(install-complex-package)
(define (make-complex-from-real-imag x y)
  ((get 'make-from-real-imag 'complex) x y))
(define (make-complex-from-mag-ang r a)
  ((get 'make-from-mag-ang 'complex) r a))
(define (install-equ-package)
  ;;schematic number
  (put 'equ? '(integer integer)
       (lambda (n1 n2) (= n1 n2)))
  (put 'equ? '(real real)
       (lambda (n1 n2) (= n1 n2)))

  ;;rational number
  (define (numer r) (car r))
  (define (denom r) (cdr r))
  (put 'equ? '(rational rational)
       (lambda (r1 r2)
	 (and (equ? (numer r1) (numer r2))
	      (equ? (denom r1) (denom r2)))))
  
  ;;complex number
  (put 'equ? '(complex complex)
       (lambda (z1 z2)
	 (and (equ? (real-part z1) (real-part z2))
	      (equ? (imag-part z1) (imag-part z2)))))
  'done
)
(install-equ-package)
(define  (equ? x y) (apply-generic 'equ? x y))
(define (install-zero?)
;;schematic number
  (put '=zero? '(integer)
       (lambda (n1) (= n1 0)))
(put '=zero? '(real)
       (lambda (n1) (= n1 0.0)))

  ;;rational number
  (define (numer r) (car r))
  ;(define (denom r) (cdr r))
  (put '=zero? '(rational)
       (lambda (r1)
	 (= (numer r1) 0))) 
  ;;complex number
  (put '=zero? '(complex)
       (lambda (z1)
	 (and (equ? (real-part z1) 0)
	      (equ? (imag-part z1) 0))))

  'done
)
(install-zero?)
(define (=zero? x) (apply-generic '=zero? x))
(define (negative x) (apply-generic 'negative x))
