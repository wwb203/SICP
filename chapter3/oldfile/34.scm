(define (last-pair l)
  (if (null? (cdr l))
    l
    (last-pair (cdr l))))
(define (make-cycle l)
  (set-cdr! (last-pair l)
	    l)
  l)
(define (append! x y)
  (if (not (pair? x)) (set! x (cons y x))  
  (set-cdr! (last-pair x) y))
  x)
(define (find? x l)
(cond ((null? l) #f)
      ((eq? x (car l)) #t)
      (else (find? x (cdr l)))))
(define (count-pairs-sub x record)
  (define (sub l)
    (cond ((null? l) 0)
	  ((not (pair? l)) 0)
	  ((find? l record) 0)
	  (else
	    (set! record (cons l record))
	     (+ 1
		(sub (car l))
		(sub (cdr l)))))) 
  (sub x)
)
(define (count-pairs x)
  (count-pairs-sub x (list)))
(define (safe-cdr x)
  (if (not (pair? x)) '()
    (cdr x)))
(define (safe-cddr x)
  (safe-cdr (safe-cdr x)))
(define (loop? x)
  (define (crawl slow fast)
    (cond ((or (null? slow) (null? fast))
	   false)
      	  ((eq? slow fast) true) 
	(else  (crawl (safe-cdr slow) (safe-cddr fast)))))
  (crawl x (safe-cddr x))) 
(define (cons x y)
  (define (set-x! v) (set! x v))
  (define (set-y! v) (set! y v))
  (define (dispatch m)
    (cond ((eq? m 'car) x)
	  ((eq? m 'cdr) y)
	  ((eq? m 'set-car!) set-x!)
	  ((eq? m 'set-cdr!) set-y!)
	  (else (error "Undefined
		       operation: CONS" m))))
  dispatch
  )
(define (car z) (z 'car))
(define (cdr z) (z 'cdr))
(define (set-car! z value) ((z 'set-car!) value) z)
(define (set-cdr! z value) ((z 'set-cdr!) value) z)



